


PGF90 (Version     14.9)          03/12/2015  00:11:49      page 1

Switches: -noasm -nodclchk -debug -nodlines -line -list
          -idir /opt/cray/hdf5/1.8.13/PGI/141/include
          -idir /opt/cray/mpt/7.0.4/gni/mpich2-pgi/141/include
          -idir /opt/cray/rca/1.0.0-2.0502.53711.3.127.ari/include
          -idir /opt/cray/xpmem/0.1-2.0502.55507.3.2.ari/include
          -idir /opt/cray/gni-headers/3.0-1.0502.9684.5.2.ari/include
          -idir /opt/cray/pmi/5.0.4-1.0000.10161.132.4.ari/include
          -idir /opt/cray/ugni/5.0-1.0502.9685.4.24.ari/include
          -idir /opt/cray/udreg/2.3.2-1.0502.9275.1.12.ari/include
          -idir /opt/cray/alps/5.2.1-2.0502.9072.13.1.ari/include
          -idir /opt/cray/wlm_detect/1.0-1.0502.53341.1.1.ari/include
          -idir /opt/cray/alps/5.2.1-2.0502.9072.13.1.ari/include
          -idir /opt/cray/krca/1.0.0-2.0502.53880.4.104.ari/include
          -idir /opt/cray-hss-devel/7.2.0/include
          -inform severe -opt 0 -nosave -object -noonetrip
          -depchk on -nostandard     
          -symbol -noupcase    

Filename: ../../../Distributions/Source/wlInterpolationModule.f90

(    1) MODULE wlInterpolationModule
(    2) 
(    3)   USE wlKindModule, ONLY: dp
(    4) 
(    5)   implicit none
(    6) 
(    7)   PUBLIC LogInterpolateSingleVariable
(    8)   PUBLIC locate 
(    9)   PUBLIC MonotonicityCheck
(   10) 
(   11) CONTAINS
(   12) 
(   13)   SUBROUTINE locate( xx, n, x, j )
(   14) 
(   15)     INTEGER, INTENT(in)      :: n
(   16)     INTEGER, INTENT(out)     :: j
(   17)     REAL(dp), INTENT(in)     ::  x,xx(n)
(   18)     INTEGER                  ::  jl,jm,ju
(   19) 
(   20)     jl = 0
(   21)     ju = n+1
(   22)     DO WHILE ( ju - jl > 1 )
(   23)       jm = (ju+jl)/2
(   24)       IF ((xx(n).ge.xx(1)).eqv.(x.ge.xx(jm))) THEN
(   25)         jl = jm
(   26)       ELSE
(   27)         ju = jm
(   28)       END IF
(   29)     END DO
(   30) 
(   31)     IF (x.eq.xx(1)) THEN
(   32)       j = 1
(   33)     ELSEIF (x.eq.xx(n)) THEN
(   34)       j = n-1
(   35)     ELSE
(   36)       j = jl
(   37)     END IF
(   38) 
(   39)   END SUBROUTINE locate






PGF90 (Version     14.9)          03/12/2015  00:11:49      page 2

(   40) 
(   41)   SUBROUTINE LogInterpolateSingleVariable( x1, x2, x3, Coordinate1, Coordinate2, &
(   42)                                            Coordinate3, LogInterp, Table, Interpolant )
(   43) 
(   44)     REAL(dp), DIMENSION(:), INTENT(in) :: x1
(   45)     REAL(dp), DIMENSION(:), INTENT(in) :: x2
(   46)     REAL(dp), DIMENSION(:), INTENT(in) :: x3
(   47)     REAL(dp), DIMENSION(:), INTENT(in) :: Coordinate1
(   48)     REAL(dp), DIMENSION(:), INTENT(in) :: Coordinate2
(   49)     REAL(dp), DIMENSION(:), INTENT(in) :: Coordinate3
(   50)     LOGICAL, DIMENSION(3), INTENT(in)  :: LogInterp 
(   51)     REAL(dp), DIMENSION(:,:,:), INTENT(in) :: Table
(   52)     
(   53)     INTEGER :: i
(   54) 
(   55)     REAL(dp), DIMENSION(:), INTENT(out) :: Interpolant 
(   56) 
(   57)     REAL(dp) :: p000, p100, p010, p001, p011, p101, p110, p111
(   58)     REAL(dp), DIMENSION(3) :: delta
(   59)     INTEGER :: il1, il2, il3
(   60)   
(   61)     DO i = 1, SIZE(x1)  
(   62)   
(   63)       CALL locate( Coordinate1, SIZE(Coordinate1), x1(i), il1 ) 
(   64)       CALL locate( Coordinate2, SIZE(Coordinate2), x2(i), il2 )
(   65)       CALL locate( Coordinate3, SIZE(Coordinate3), x3(i), il3 )
(   66)     
(   67)       p000 = Table( il1  , il2  , il3   )
(   68)       p100 = Table( il1+1, il2  , il3   )
(   69)       p010 = Table( il1  , il2+1, il3   )
(   70)       p110 = Table( il1+1, il2+1, il3   )
(   71)       p001 = Table( il1  , il2  , il3+1 )
(   72)       p101 = Table( il1+1, il2  , il3+1 )
(   73)       p011 = Table( il1  , il2+1, il3+1 )
(   74)       p111 = Table( il1+1, il2+1, il3+1 )
(   75) 
(   76)       IF ( LogInterp(1) ) THEN 
(   77)       delta(1) = LOG10( x1(i) - Coordinate1(il1) ) / LOG10( Coordinate1(il1+1) - Coordinate1(il1) )
(   78)       ELSE
(   79)       delta(1) = ( x1(i) - Coordinate1(il1) ) / ( Coordinate1(il1+1) - Coordinate1(il1) )
(   80)       END IF
(   81) 
(   82)       IF ( LogInterp(2) ) THEN 
(   83)       delta(2) = LOG10( x2(i) - Coordinate2(il2) ) / LOG10( Coordinate2(il2+1) - Coordinate2(il2) )
(   84)       ELSE
(   85)       delta(2) = ( x2(i) - Coordinate2(il2) ) / ( Coordinate2(il2+1) - Coordinate2(il2) )
(   86)       END IF
(   87) 
(   88)       IF ( LogInterp(3) ) THEN 
(   89)       delta(3) = LOG10( x3(i) - Coordinate3(il3) ) / LOG10( Coordinate3(il3+1) - Coordinate3(il3) )
(   90)       ELSE
(   91)       delta(3) = ( x3(i) - Coordinate3(il3) ) / ( Coordinate3(il3+1) - Coordinate3(il3) )
(   92)       END IF
(   93) 
(   94)       Interpolant(i) &
(   95)         = 10.d0**( &
(   96)               (1.0_dp - delta(3)) * ( (1.0_dp - delta(1)) * (1.0_dp - delta(2)) * p000   &                
(   97)                                    +            delta(1)  * (1.0_dp - delta(2)) * p100   &






PGF90 (Version     14.9)          03/12/2015  00:11:49      page 3

(   98)                                    + ( 1.0_dp - delta(1)) *           delta(2)  * p010   &
(   99)                                    +            delta(1)  *           delta(2)  * p110 ) &
(  100)                       + delta(3)  * ( (1.0_dp - delta(1)) * (1.0_dp - delta(2)) * p001   &
(  101)                                    +            delta(1)  * (1.0_dp - delta(2)) * p101   &
(  102)                                    +  (1.0_dp - delta(1)) *           delta(2)  * p011   &
(  103)                                    +            delta(1)  *           delta(2)  * p111 ) &
(  104)  
(  105)                  ) 
(  106)     END DO 
(  107) 
(  108)   END SUBROUTINE LogInterpolateSingleVariable
(  109) 
(  110)   
(  111)   SUBROUTINE MonotonicityCheck ( Table, Nrho, NT, NYe, Axis )
(  112) 
(  113)     REAL(dp), DIMENSION(:,:,:), INTENT(in) :: Table
(  114)     INTEGER, INTENT(in) :: Nrho 
(  115)     INTEGER, INTENT(in) :: NT
(  116)     INTEGER, INTENT(in) :: NYe
(  117)     INTEGER, INTENT(in) :: Axis
(  118) 
(  119)     INTEGER :: i, j, k, count
(  120) 
(  121)     97 FORMAT ("Table not monotonic in rho at (Nrho, NT, NYe) = ", 3(1x,i4) )
(  122)     98 FORMAT ("Table not monotonic in T at (Nrho, NT, NYe) = ", 3(1x,i4) )
(  123)     99 FORMAT ("Table not monotonic in Ye at (Nrho, NT, NYe) = ", 3(1x,i4) )
(  124)  
(  125)     count = 0
(  126)     
(  127)     SELECT CASE ( Axis ) 
(  128)      
(  129)     CASE( 1 )
(  130)       DO k = 1, NYe
(  131)         DO j = 1, NT  
(  132)           DO i = 2, Nrho - 1
(  133) 
(  134)             IF ( ( ( Table(i+1, j, k) - Table(i, j, k) ) * &
(  135)                  ( Table(i, j, k) - Table(i-1, j, k) ) ) < 0. ) THEN
(  136)               WRITE (*,97) i, j, k
(  137)               count = count + 1
(  138)             END IF
(  139)           END DO
(  140)         END DO
(  141)       END DO
(  142) 
(  143)     CASE( 2 )
(  144)       DO k = 1, NYe
(  145)         DO j = 2, NT - 1 
(  146)           DO i = 1, Nrho
(  147) 
(  148)             IF ( ( ( Table(i, j+1, k) - Table(i, j, k) ) * &
(  149)                  ( Table(i, j, k) - Table(i, j-1, k) ) ) < 0.) THEN 
(  150)               WRITE (*,98) i, j, k
(  151)               count = count + 1
(  152)             END IF
(  153)           END DO
(  154)         END DO
(  155)       END DO






PGF90 (Version     14.9)          03/12/2015  00:11:49      page 4

(  156) 
(  157)    CASE( 3 )
(  158)       DO k = 2, NYe - 1
(  159)         DO j = 1, NT
(  160)           DO i = 1, Nrho
(  161) 
(  162)             IF ( ( ( Table(i, j, k+1) - Table(i, j, k) ) * &
(  163)                  ( Table(i, j, k) - Table(i, j, k-1) ) ) < 0. ) &
(  164)             WRITE (*, 99) i, j, k
(  165) 
(  166)           END DO
(  167)         END DO
(  168)       END DO
(  169) 
(  170)     CASE DEFAULT
(  171)       WRITE (*,*) "Invalid Axis", Axis
(  172)       STOP
(  173) 
(  174)     END SELECT
(  175)     WRITE (*,*) count, " Non-monotonic out of " , NYe*NT*Nrho
(  176) 
(  177)   END SUBROUTINE MonotonicityCheck 
(  178) 
(  179) !  SUBROUTINE LogSecantInterpolateSingleVariable( Coordinate1, Coordinate2, Interpolant  ) 
(  180) !    REAL(dp), DIMENSION(:), INTENT(in) :: Coordinate1
(  181) !    REAL(dp), DIMENSION(:), INTENT(in) :: Coordinate2
(  182)     
(  183) !    INTEGER :: i
(  184) 
(  185) !    REAL(dp), DIMENSION(:), INTENT(out) :: Interpolant 
(  186) 
(  187) !  END SUBROUTINE LogSecantInterpolateSingleVariable
(  188) 
(  189) END MODULE wlInterpolationModule
(  190) 
